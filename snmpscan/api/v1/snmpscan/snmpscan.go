/*
Package scan implements bunch of handlers which serve scan gRPC APIs, DO NOT CHANGE THE package name. It was
generated by code generator.

*/
package snmpscan

import (
	"context"
	"errors"
	"fmt"
	"io"
	"math/big"
	"nms/snmpscan/pkg/scan"
	"nms/snmpscan/pkg/snmp"
	"strconv"
	"time"

	api "nms/api/v1/snmpscan"

	"github.com/gosnmp/gosnmp"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"

	"google.golang.org/grpc"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

type Server struct {
	api.UnimplementedSnmpScanServer
}

func RegisterServices(s *grpc.Server) error {
	api.RegisterSnmpScanServer(s, &Server{})
	return nil
}

// snmpResulttoPDU convert gosnmp.SnmpPDU to prpcsnmp.PDU
func snmpResulttoPDU(v snmp.ResultItem) (api.PDU, error) {
	var pbV *structpb.Value
	var err error
	switch t := v.Value.(type) {
	case *big.Int:
		pbV, err = structpb.NewValue(t.String())
	default:
		pbV, err = structpb.NewValue(t)
	}
	if err != nil {
		return api.PDU{}, err
	}
	return api.PDU{
		Value: pbV,
		Name:  v.Name,
		Kind:  v.Kind,
	}, nil
}

// convertToSnmpOption convert gRPC SnmpSettings to snmp.SnmpOption.
//
func convertToSnmpOption(in *api.SnmpSettings) *snmp.SnmpOption {
	var opt *snmp.SnmpOption
	if in == nil {
		log.Info("Missing snmp settings,  insteed of default settings")
		opt = &snmp.SnmpOption{}
		viper.UnmarshalKey("snmp", opt)
		timeout := viper.GetInt("snmp.timeout")
		if timeout <= 0 {
			timeout = 1
		}
		opt.Timeout = time.Duration(timeout) * time.Second

		//opt = nil
	} else {
		opt = &snmp.SnmpOption{
			Port:      uint16(in.Port),
			Community: in.ReadCommunity,
			Version:   gosnmp.SnmpVersion(in.Version),
			Timeout:   time.Duration(2) * time.Second,
		}
	}
	return opt
}

//Get gRPC handler
func (s *Server) Get(req *api.GetRequest, stream api.SnmpScan_GetServer) error {
	if req == nil {
		log.Error("SnmpService/Get request is null")
		return errors.New("SnmpService/Get request is null")
	}
	opt := convertToSnmpOption(req.SnmpSettings)

	results, err := snmp.Get(req.Target, req.Oids, opt)
	if err != nil {
		return err
	}
	if len(results) <= 0 {
		return errors.New("No result")
	}
	for _, v := range results {
		pdu, err := snmpResulttoPDU(v)
		if err != nil {
			return err
		}
		if err = stream.Send(&pdu); err != nil {
			return err
		}
	}
	return nil
}

// Scan
func (s *Server) Scan(req *api.ScanRequest, stream api.SnmpScan_ScanServer) error {

	opt := convertToSnmpOption(req.SnmpSettings)
	var results []scan.ScanResults
	var err error
	if req.AtopDevices {
		results, err = scan.ScanAtopDevices(req.Range, opt)
	} else {
		results, err = scan.ScanAgent(req.Range, req.Oids, opt)
	}

	if err != nil {
		return err
	}
	for _, r := range results {
		var pdus []*api.PDU
		for _, kv := range r {
			i, err := snmpResulttoPDU(kv)
			if err != nil {
				log.Errorf("Convert %#v snmp result to grpc result fail err: %+v", kv, err)
				continue
			}
			pdus = append(pdus, &i)

		}
		ret := api.ScanResult{
			Pdus: pdus,
		}

		stream.Send(&ret)
	}

	return nil
}

func snmpPublicMatrixToAPI(matrix snmp.PublicMatrix) *api.PublicMatrix {
	ret := &api.PublicMatrix{
		SysDescr:    matrix.SysDescr,
		SysObjectId: matrix.SysObjectId,
		SysUpTime:   matrix.SysUpTime,
		SysContact:  matrix.SysContact,
		SysName:     matrix.SysName,
		SysLocation: matrix.SysLocation,
		SysServices: matrix.SysServices,
		Interfaces:  []*api.PublicMatrix_Interfaces{},
	}
	for _, v := range matrix.Interfaces {
		idx, _ := strconv.ParseInt(v.Index, 10, 32)
		ret.Interfaces = append(ret.Interfaces, &api.PublicMatrix_Interfaces{

			IfIndex:              int32(idx),
			IfDescr:              v.Descr,
			IfPhysAddress:        v.PhysAddress,
			IfAdminStatus:        v.AdminStatus,
			IfOperStatus:         v.OperStatus,
			IfInNUcastPkts:       v.InNUcastPkts,
			IfOutErrors:          v.OutErrors,
			IfHCInOctets:         v.HCInOctets,
			IfHCInUcastPkts:      v.HCInUcastPkts,
			IfHCInMulticastPkts:  v.HCInMulticastPkts,
			IfHCInBroadcastPkts:  v.HCInBroadcastPkts,
			IfHCOutOctets:        v.HCOutOctets,
			IfHCOutUcastPkts:     v.HCOutUcastPkts,
			IfHCOutMulticastPkts: v.HCOutMulticastPkts,
			IfHCOutBroadcastPkts: v.HCOutBroadcastPkts,
			IfHighSpeed:          v.HighSpeed})
	}
	return ret
}

func (s *Server) Describe(ctx context.Context, req *api.DescribeRequest) (*api.DescribeResult, error) {
	opt := convertToSnmpOption(req.SnmpSettings)
	ret, err := snmp.Describe(req.Target, opt)
	if err != nil {
		log.Errorf("grpc API Describe error : %+v", err)
		return &api.DescribeResult{}, err
	}

	apiMatrix := snmpPublicMatrixToAPI(ret)
	return &api.DescribeResult{
		Information: apiMatrix,
	}, nil
}

// StartAsyncScan
func (s *Server) StartAsyncScan(srv api.SnmpScan_StartAsyncScanServer) error {
	ctx := srv.Context()
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		//receive request
		req, err := srv.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			log.Errorf("receive request from client error: %+v", err)
			continue
		}
		opt := convertToSnmpOption(req.SnmpSettings)
		id := scan.CreateSession()
		if err := srv.Send(&api.AsyncResponse{
			SessionId: id,
			Success:   true,
		}); err != nil {
			log.Errorf("async scan was fail: %+v", err)
			scan.SessionFail(id, err)
			continue
		}
		scan.AsyncScan(id, req.Range, req.Oids, opt, req.AtopDevices)
	}
}

func (s *Server) StopAsyncScan(ctx context.Context, req *api.AsyncRequest) (*api.AsyncResponse, error) {
	return &api.AsyncResponse{
		SessionId: req.SessionId,
		Success:   true,
	}, nil
}

// GetAsyncScanResult specific async scan's last status & result
func (s *Server) GetAsyncScanResult(ctx context.Context, req *api.AsyncRequest) (*api.AsyncScanResult, error) {
	ret, err := scan.GetAsyncResult(req.SessionId)
	if err != nil {
		log.Errorf("get session %s fail: %+v", req.SessionId, err)
		return &api.AsyncScanResult{}, err
	}
	if ret.Payload == nil {
		err := fmt.Errorf("get nil payload in the %s session's result", req.SessionId)
		log.Error(err)
		return &api.AsyncScanResult{}, err
	}

	scanresults := []*api.ScanResult{}
	for _, r := range ret.Payload {
		var pdus []*api.PDU
		for _, kv := range r {
			i, err := snmpResulttoPDU(kv)
			if err != nil {
				log.Errorf("Convert %#v snmp result to grpc result fail err: %+v", kv, err)
				continue
			}
			pdus = append(pdus, &i)

		}
		ret := &api.ScanResult{
			Pdus: pdus,
		}
		scanresults = append(scanresults, ret)

	}

	return &api.AsyncScanResult{
		SessionId: ret.SessionID,
		Success:   true,
		Status:    ret.State,
		TimeStamp: ret.TimeStamp,
		Result:    scanresults,
	}, nil
}

func (s *Server) SessionScan(in *api.SessionScanRequest, stream api.SnmpScan_SessionScanServer) error {

	//receive request
	req := in.ScanRequest

	opt := convertToSnmpOption(req.SnmpSettings)

	if err := stream.Send(&api.SessionScanResponse{
		SessionId: in.SessionId,
		State:     "running",
	}); err != nil {
		log.Errorf("SessionScan stream send fail: %+v", err)
		scan.SessionFail(in.SessionId, err)
	}
	scan.AsyncScan(in.SessionId, req.Range, req.Oids, opt, req.AtopDevices)
	return nil
}
